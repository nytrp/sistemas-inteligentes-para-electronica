# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qV7JaUxxNlAKi2bfeE5iy90N--3fTc4M
"""

// Sketch minimalista: TCS34725 + IQR + EEPROM + KNN manual (sin librería)
// Baud: 115200
#include <Wire.h>
#include <Adafruit_TCS34725.h>
#include <EEPROM.h>
#include <math.h>

// Sensor
Adafruit_TCS34725 tcs = Adafruit_TCS34725(
  TCS34725_INTEGRATIONTIME_50MS,
  TCS34725_GAIN_4X
);

// Constantes
const uint8_t SAMPLES = 20;
const int INPUTS = 3; // r,g,b normalizados

// EEPROM layout
const int ADDR_RED    = 0;
const int ADDR_ORANGE = 8;
const int ADDR_GREEN  = 16;
const int ADDR_MAGIC  = 24;
const uint8_t MAGIC_BYTE = 0xA5;

// EEPROM helpers
void writeUInt16ToEEPROM(int addr, uint16_t value) {
  EEPROM.update(addr, value & 0xFF);
  EEPROM.update(addr + 1, (value >> 8) & 0xFF);
}
uint16_t readUInt16FromEEPROM(int addr) {
  uint16_t low = EEPROM.read(addr);
  uint16_t high = EEPROM.read(addr + 1);
  return (high << 8) | low;
}
void setMagic() { EEPROM.update(ADDR_MAGIC, MAGIC_BYTE); }
void clearMagic() { EEPROM.update(ADDR_MAGIC, 0xFF); }
bool isMagicPresent() { return (EEPROM.read(ADDR_MAGIC) == MAGIC_BYTE); }

// Estadística / IQR
uint16_t medianUint16(uint16_t arr[], uint8_t n) {
  if (n == 0) return 0;
  uint16_t tmp[SAMPLES];
  for (uint8_t i = 0; i < n; i++) tmp[i] = arr[i];
  for (uint8_t i = 0; i < n; i++) {
    for (uint8_t j = i + 1; j < n; j++) {
      if (tmp[j] < tmp[i]) {
        uint16_t t = tmp[i]; tmp[i] = tmp[j]; tmp[j] = t;
      }
    }
  }
  if (n % 2 == 1) return tmp[n / 2];
  uint32_t a = tmp[n / 2 - 1], b = tmp[n / 2];
  return (uint16_t)((a + b) / 2);
}
float medianOfSortedRange(uint16_t sorted[], int start, int end) {
  int len = end - start + 1;
  if (len <= 0) return 0.0;
  int midIndex = start + len / 2;
  if (len % 2 == 1) return (float)sorted[midIndex];
  return ((float)sorted[midIndex - 1] + (float)sorted[midIndex]) / 2.0;
}
void computeQ1Q3(uint16_t samples[], uint8_t n, float &q1, float &q3) {
  uint16_t tmp[SAMPLES];
  for (uint8_t i = 0; i < n; i++) tmp[i] = samples[i];
  for (uint8_t i = 0; i < n; i++) {
    for (uint8_t j = i + 1; j < n; j++) {
      if (tmp[j] < tmp[i]) {
        uint16_t t = tmp[i]; tmp[i] = tmp[j]; tmp[j] = t;
      }
    }
  }
  if (n == 0) { q1 = q3 = 0.0; return; }
  if (n % 2 == 0) {
    q1 = medianOfSortedRange(tmp, 0, n/2 - 1);
    q3 = medianOfSortedRange(tmp, n/2, n - 1);
  } else {
    q1 = medianOfSortedRange(tmp, 0, n/2 - 1);
    q3 = medianOfSortedRange(tmp, n/2 + 1, n - 1);
  }
}
uint16_t cleanChannelIQR(uint16_t samples[], uint8_t n) {
  if (n == 0) return 0;
  float q1, q3; computeQ1Q3(samples, n, q1, q3);
  float iqr = q3 - q1;
  float lower = q1 - 1.5 * iqr;
  float upper = q3 + 1.5 * iqr;
  uint32_t sum = 0; uint8_t kept = 0;
  for (uint8_t i = 0; i < n; i++) {
    float v = (float)samples[i];
    if (v >= lower && v <= upper) { sum += samples[i]; kept++; }
  }
  if (kept == 0) return medianUint16(samples, n);
  float avg = (float)sum / kept;
  if (avg < 0) avg = 0; if (avg > 65535) avg = 65535;
  return (uint16_t)(avg + 0.5);
}

// Storage RAM copy (una muestra por clase, como tu sketch actual)
struct ColorVals { uint16_t r, g, b, c; };
ColorVals storedColors[3];
const char* namesStored[3] = {"ROJO", "NARANJA", "VERDE"};

// Load EEPROM -> RAM using magic
void loadStoredColorsFromEEPROM() {
  if (!isMagicPresent()) {
    for (uint8_t i = 0; i < 3; i++) { storedColors[i].r = storedColors[i].g = storedColors[i].b = storedColors[i].c = 0; }
    Serial.println("INFO: EEPROM no contiene calibración válida.");
    return;
  }
  storedColors[0].r = readUInt16FromEEPROM(ADDR_RED + 0);
  storedColors[0].g = readUInt16FromEEPROM(ADDR_RED + 2);
  storedColors[0].b = readUInt16FromEEPROM(ADDR_RED + 4);
  storedColors[0].c = readUInt16FromEEPROM(ADDR_RED + 6);

  storedColors[1].r = readUInt16FromEEPROM(ADDR_ORANGE + 0);
  storedColors[1].g = readUInt16FromEEPROM(ADDR_ORANGE + 2);
  storedColors[1].b = readUInt16FromEEPROM(ADDR_ORANGE + 4);
  storedColors[1].c = readUInt16FromEEPROM(ADDR_ORANGE + 6);

  storedColors[2].r = readUInt16FromEEPROM(ADDR_GREEN + 0);
  storedColors[2].g = readUInt16FromEEPROM(ADDR_GREEN + 2);
  storedColors[2].b = readUInt16FromEEPROM(ADDR_GREEN + 4);
  storedColors[2].c = readUInt16FromEEPROM(ADDR_GREEN + 6);
}

// Sampling helper (take SAMPLES and clean)
void takeSampleAndClean(uint16_t &rOut, uint16_t &gOut, uint16_t &bOut, uint16_t &cOut, bool verbose=true) {
  uint16_t rSamples[SAMPLES], gSamples[SAMPLES], bSamples[SAMPLES], cSamples[SAMPLES];
  for (uint8_t i = 0; i < SAMPLES; i++) {
    uint16_t r,g,b,c;
    tcs.getRawData(&r,&g,&b,&c);
    rSamples[i] = r; gSamples[i] = g; bSamples[i] = b; cSamples[i] = c;
    if (verbose) {
      Serial.print("Muestra "); Serial.print(i+1);
      Serial.print(" -> R:"); Serial.print(r);
      Serial.print(" G:"); Serial.print(g);
      Serial.print(" B:"); Serial.print(b);
      Serial.print(" C:"); Serial.println(c);
    }
    delay(120);
  }
  rOut = cleanChannelIQR(rSamples, SAMPLES);
  gOut = cleanChannelIQR(gSamples, SAMPLES);
  bOut = cleanChannelIQR(bSamples, SAMPLES);
  cOut = cleanChannelIQR(cSamples, SAMPLES);
}

// ------------------------------------------------------------------------
// KNN manual (sin librería)
// ------------------------------------------------------------------------
int K = 1; // vecinos
// dataset built from storedColors; maximum 3 examples (one per class in this sketch)
float datasetX[3][3]; // datasetX[i] = {r_norm,g_norm,b_norm}
int datasetLabels[3];
int datasetSize = 0;
bool knnTrained = false;

// Normalize helper
void normalizeRGBtoFloat(uint16_t r, uint16_t g, uint16_t b, uint16_t c, float &rn, float &gn, float &bn) {
  if (c > 0) {
    rn = (float)r / (float)c;
    gn = (float)g / (float)c;
    bn = (float)b / (float)c;
  } else {
    uint32_t sum = (uint32_t)r + (uint32_t)g + (uint32_t)b;
    if (sum > 0) {
      rn = (float)r / (float)sum;
      gn = (float)g / (float)sum;
      bn = (float)b / (float)sum;
    } else rn = gn = bn = 0.0f;
  }
}

// Build dataset from storedColors[] (call after load or after saving)
void buildManualDataset() {
  datasetSize = 0;
  for (int i = 0; i < 3; i++) {
    ColorVals sc = storedColors[i];
    // consider valid if not all zero
    if (sc.r == 0 && sc.g == 0 && sc.b == 0 && sc.c == 0) continue;
    float rn, gn, bn;
    normalizeRGBtoFloat(sc.r, sc.g, sc.b, sc.c, rn, gn, bn);
    datasetX[datasetSize][0] = rn;
    datasetX[datasetSize][1] = gn;
    datasetX[datasetSize][2] = bn;
    datasetLabels[datasetSize] = i; // label 0..2
    datasetSize++;
  }
  knnTrained = (datasetSize > 0);
  Serial.print("buildManualDataset: ejemplos disponibles = ");
  Serial.println(datasetSize);
}

// Euclidean distance between two 3-D float vectors
float euclideanDist3(const float a[3], const float b0, const float b1, const float b2) {
  float dr = a[0] - b0;
  float dg = a[1] - b1;
  float db = a[2] - b2;
  return sqrt(dr*dr + dg*dg + db*db);
}

// classify using manual KNN: returns class index (0..2) or -1 on failure
int classifyManual(uint16_t r, uint16_t g, uint16_t b, uint16_t c) {
  if (!knnTrained || datasetSize == 0) {
    Serial.println("KNN manual: no entrenado. Use S/A para crear ejemplos.");
    return -1;
  }

  float rn, gn, bn;
  normalizeRGBtoFloat(r, g, b, c, rn, gn, bn);

  // compute distances
  float dists[3];
  int labels[3];
  const float INF = 1e9f;
  for (int i = 0; i < datasetSize; i++) {
    float px[3] = { datasetX[i][0], datasetX[i][1], datasetX[i][2] };
    dists[i] = euclideanDist3(px, rn, gn, bn);
    labels[i] = datasetLabels[i];
  }
  // if datasetSize < 3, init remaining dists to INF
  for (int i = datasetSize; i < 3; i++) { dists[i] = INF; labels[i] = -1; }

  // find K nearest by simple selection (datasetSize is small)
  int kActual = K;
  if (kActual > datasetSize) kActual = datasetSize;

  // We'll mark taken indices
  bool taken[3] = {false, false, false};
  int voteCounts[3] = {0,0,0};
  int nearestLabel = -1;
  float nearestDist = INF;

  for (int k = 0; k < kActual; k++) {
    // find smallest distance among not taken
    int bestIdx = -1;
    float bestD = INF;
    for (int i = 0; i < datasetSize; i++) {
      if (!taken[i] && dists[i] < bestD) {
        bestD = dists[i];
        bestIdx = i;
      }
    }
    if (bestIdx == -1) break;
    taken[bestIdx] = true;
    int lbl = labels[bestIdx];
    if (lbl >= 0 && lbl < 3) voteCounts[lbl]++;
    // track globally nearest (for tie-breaker)
    if (bestD < nearestDist) {
      nearestDist = bestD;
      nearestLabel = lbl;
    }
  }

  // decide winner by majority vote
  int bestLabel = -1;
  int bestVotes = -1;
  for (int lbl = 0; lbl < 3; lbl++) {
    if (voteCounts[lbl] > bestVotes) {
      bestVotes = voteCounts[lbl];
      bestLabel = lbl;
    }
  }
  // check tie: if multiple labels have same bestVotes (>0), break by nearestLabel
  if (bestVotes > 0) {
    int tieCount = 0;
    for (int lbl = 0; lbl < 3; lbl++) if (voteCounts[lbl] == bestVotes) tieCount++;
    if (tieCount > 1) {
      // choose nearestLabel (computed above)
      if (nearestLabel != -1) bestLabel = nearestLabel;
    }
  } else {
    // no votes (shouldn't happen) -> choose nearestLabel
    bestLabel = nearestLabel;
  }

  // print diagnostics
  Serial.println("--- Clasificación (KNN manual) ---");
  Serial.print("Sensor -> R:"); Serial.print(r); Serial.print(" G:"); Serial.print(g);
  Serial.print(" B:"); Serial.print(b); Serial.print(" C:"); Serial.println(c);
  Serial.print("Normalizado -> r:"); Serial.print(rn,4); Serial.print(" g:"); Serial.print(gn,4); Serial.print(" b:"); Serial.println(bn,4);
  Serial.print("K usado: "); Serial.println(kActual);
  for (int i = 0; i < datasetSize; i++) {
    Serial.print("Ejemplo "); Serial.print(i); Serial.print(" cls="); Serial.print(datasetLabels[i]);
    Serial.print(" vec=("); Serial.print(datasetX[i][0],4); Serial.print(","); Serial.print(datasetX[i][1],4); Serial.print(","); Serial.print(datasetX[i][2],4);
    Serial.print(") dist="); Serial.println(dists[i],6);
  }

  if (bestLabel >= 0 && bestLabel < 3) {
    Serial.print("Resultado: ");
    Serial.println(namesStored[bestLabel]);
  } else {
    Serial.println("Resultado: indeterminado.");
  }

  return bestLabel;
}

// scan & store (writes magic, updates RAM and rebuild dataset)
void scanAndStoreColor(const char* colorName, int startAddr) {
  Serial.print("Iniciando muestreo para color: ");
  Serial.println(colorName);
  uint16_t rClean,gClean,bClean,cClean;
  takeSampleAndClean(rClean,gClean,bClean,cClean,true);
  Serial.print("Valores limpios "); Serial.print(colorName);
  Serial.print(" R:"); Serial.print(rClean);
  Serial.print(" G:"); Serial.print(gClean);
  Serial.print(" B:"); Serial.print(bClean);
  Serial.print(" C:"); Serial.println(cClean);

  writeUInt16ToEEPROM(startAddr + 0, rClean);
  writeUInt16ToEEPROM(startAddr + 2, gClean);
  writeUInt16ToEEPROM(startAddr + 4, bClean);
  writeUInt16ToEEPROM(startAddr + 6, cClean);

  // set magic and update RAM
  setMagic();
  loadStoredColorsFromEEPROM();
  Serial.println("Guardado en EEPROM y RAM actualizado.");

  // rebuild manual dataset
  buildManualDataset();
}

// print stored
void printStoredColors() {
  Serial.println("--- Valores almacenados (RAM) ---");
  if (!isMagicPresent()) Serial.println("ATENCIÓN: No hay calibración válida guardada.");
  for (uint8_t i=0;i<3;i++) {
    Serial.print(namesStored[i]); Serial.print(" -> R:"); Serial.print(storedColors[i].r);
    Serial.print(" G:"); Serial.print(storedColors[i].g);
    Serial.print(" B:"); Serial.print(storedColors[i].b);
    Serial.print(" C:"); Serial.println(storedColors[i].c);
  }
  Serial.println("---------------------------------");
}

// ------------------------------------------------------------------------

int nextColorIndex = 0;
const int colorAddrs[3] = { ADDR_RED, ADDR_ORANGE, ADDR_GREEN };
const char* colorNames[3] = { "ROJO", "NARANJA", "VERDE" };

void setup() {
  Serial.begin(115200);
  delay(200);
  Serial.println("TCS34725 + IQR + EEPROM + KNN manual (sin libreria)");
  if (!tcs.begin()) {
    Serial.println("ERROR: tcs.begin() falló. Revisa conexiones.");
    while (1) delay(500);
  }
  // load stored values and build dataset if magic present
  loadStoredColorsFromEEPROM();
  if (isMagicPresent()) buildManualDataset();
  Serial.println("Comandos: S (muestra 20 y guarda siguiente color), A (guardar los 3), P (imprimir), C (clasificar), K<n> (set k)");
}

void loop() {
  // minimal: no heartbeat
  static char buf[48];
  static uint8_t idx = 0;

  while (Serial.available()) {
    char ch = (char)Serial.read();
    if (ch == '\r' || ch == '\n') {
      if (idx == 0) { /* ignore empty */ }
      else {
        buf[idx] = '\0';
        String line = String(buf);
        line.trim();
        idx = 0;
        if (line.length() == 0) break;
        char c = line.charAt(0);

        if (c == 'S' || c == 's') {
          scanAndStoreColor(colorNames[nextColorIndex], colorAddrs[nextColorIndex]);
          nextColorIndex = (nextColorIndex + 1) % 3;
          Serial.print("S terminado. siguiente: "); Serial.println(colorNames[nextColorIndex]);
        }
        else if (c == 'A' || c == 'a') {
          scanAndStoreColor("ROJO", ADDR_RED);
          scanAndStoreColor("NARANJA", ADDR_ORANGE);
          scanAndStoreColor("VERDE", ADDR_GREEN);
          nextColorIndex = 0;
          Serial.println("A terminado.");
        }
        else if (c == 'P' || c == 'p') {
          printStoredColors();
        }
        else if (c == 'C' || c == 'c') {
          uint16_t rr,gg,bb,cc;
          Serial.println("Tomando muestra para clasificar...");
          takeSampleAndClean(rr,gg,bb,cc,true);
          classifyManual(rr,gg,bb,cc);
        }
        else if (c == 'K' || c == 'k') {
          String num = line.substring(1);
          num.trim();
          if (num.length() > 0) {
            int nk = num.toInt();
            if (nk <= 0) Serial.println("K debe ser >=1");
            else { K = nk; Serial.print("K seteado a "); Serial.println(K); }
          } else {
            Serial.print("K actual = "); Serial.println(K);
            Serial.println("Cambiar con K<n> (ej: K3)");
          }
        }
        else {
          Serial.println("Comando no reconocido. Usa S, A, P, C, K<n>.");
        }
      }
    } else {
      if (idx < sizeof(buf)-1) buf[idx++] = ch;
      else idx = 0; // overflow protection
    }
  }

  delay(10);
}
